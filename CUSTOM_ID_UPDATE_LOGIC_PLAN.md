# План рефакторинга логики обновления Custom ID

## 1. Проблема

При обновлении `Item` (в `UpdateCommandHandler`), если правила генерации `customId` для инвентаря изменились, текущий `customId` элемента может стать невалидным. Существующая логика пытается решить это, генерируя новый ID с помощью `GenerateAsync`. Однако `GenerateAsync` использует общий счетчик `ItemsCount + 1` для определения порядкового номера.

Это приводит к **критическому багу**: обновленный элемент получает порядковый номер, который позже будет присвоен следующему *новому* элементу. В результате возникают дубликаты `customId`.

## 2. Предлагаемое решение: "Умное" и безопасное поведение

Реализовать механизм, который при необходимости автоматически обновляет `customId` существующего элемента, но делает это корректно, сохраняя его изначальный порядковый номер, и безопасно, учитывая бизнес-риски.

### Шаг 2.1: Определение "стабильного" порядкового номера

Вместо `ItemsCount + 1`, нужно определить реальную позицию обновляемого элемента в его последовательности.

**Действие:** Реализовать логику, которая для конкретного `Item` выполнит запрос к БД (`COUNT`) для подсчета количества элементов в том же `Inventory`, которые были созданы раньше него (сортируя по дате создания `CreatedAt` или другому стабильному полю). Результат `count + 1` и будет его стабильным порядковым номером. Это решает проблему дублирования и не влияет на производительность.

### Шаг 2.2: Модификация `ICustomIdService`

Нужно разделить логику генерации ID для нового и существующего элемента, чтобы сделать намерения явными.

**Действие:** Добавить в `ICustomIdService` новый метод, который принимает готовый порядковый номер, и переименовать старый.

```csharp
public interface ICustomIdService 
{
    // Переименовать для ясности
    Task<Result<string>> GenerateForNewAsync(ICollection<CustomIdRuleBase> rules, Guid inventoryId, CancellationToken ct);

    // Добавить новый синхронный метод для регенерации
    Result<string> GenerateFromSequence(ICollection<CustomIdRuleBase> rules, int sequence);
}
```

### Шаг 2.3 (Опционально, но рекомендовано): Настройка поведения

Чтобы избежать проблем с внешними системами (например, напечатанными этикетками), где `customId` уже используется, можно сделать автоматическое обновление настраиваемым.

**Действие:** Добавить в сущность `Inventory` новое свойство:
```csharp
public bool AutoUpdateInvalidCustomIds { get; private set; }
```

### Шаг 2.4: Рефакторинг `UpdateCommandHandler`

**Действие:** Изменить логику в `UpdateCommandHandler` (вероятно, в приватном методе `DetermineNewCustomIdAsync`).
1.  Если `customId` элемента стал невалидным из-за смены правил, проверить флаг `inventory.AutoUpdateInvalidCustomIds`.
2.  Если флаг `true`:
    *   Выполнить логику из **Шага 2.1** для определения стабильного порядкового номера.
    *   Вызвать новый метод `GenerateFromSequence` из **Шага 2.2** для получения нового `customId`.
3.  Если флаг `false`:
    *   Вернуть ошибку валидации, требуя от пользователя ввести корректный `customId` вручную.

## 3. Ожидаемый результат

- Исправлен критический баг с дублированием `customId` при обновлении элемента.
- Система гибко и предсказуемо обрабатывает смену правил генерации ID.
- Снижены бизнес-риски случайного изменения ID, используемых во внешних системах, благодаря настраиваемому поведению.
- Код в `UpdateCommandHandler` становится более читаемым и надежным.
